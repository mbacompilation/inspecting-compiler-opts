from ghidra.app.decompiler import DecompInterfacefrom ghidra.util.task import ConsoleTaskMonitorimport osimport redebug = TrueignoreWords = ["ilk", "obj", "pdb"]varnamePattern = re.compile('[a-z]Var[0-9]+')vardict = {} # global updated and cleared as needed by getVarDefs# expected function names format: mba_<number># expects no duplicates. Does not alert or throw errors if there are duplicates.# also expects range to be from 1 to <last entry>, with no skips.def getAllMBAFunctions():    # gets: list of Functions    entrycount = 1        fList = []        done = False    while (done == False):        f = getGlobalFunctions("mba_" + str(entrycount))        if (f == []):            "\n**** Got empty function list. Breaking"            done = True            break                f = f[0]        fList.append(f)        entrycount += 1            return fList            def getOriginalRetMBA(input):# takes full ghidra decompiler output for one function.    str1 = input.split("return")[1]    isolated_mba = str1.split(";")[0].replace("\n", "")    isolated_mba = isolated_mba.replace("U", "")    isolated_mba = ' '.join(isolated_mba.split())    return isolated_mbadef getVarDefs(input):    # given a full C code input from the ghidra decompiler - find and update all "var = " definitions and expand them.    # Modifies global dictionary.            # The QSynth dataset gets compiled into some if/else statements, which forces some extra parsing logic here.    # First: split by semicolons, find the ret statement, and remove it. Then join back to semicolons so that we            stmts = input.split(";")    stmtsRetRemoved = [x for x in stmts if "return" not in x]            newStr = ";".join(stmtsRetRemoved)        stmts = re.split(r'[;{}]', newStr)            varstmts = []    vardict.clear()    # just get the var = statements    for s in stmts:        if "=" in s and "return" not in s and "Var" in s:            varstmts.append((s.strip(";")).strip("\n"))    for stmt in varstmts:        sp = stmt.split("=")        # condense extra tabs and whitespaces        varname = ' '.join(sp[0].split())        vardef = ' '.join(sp[1].split())        #print("\n\n varname: " + varname + ", vardef: " + vardef)        # if this line contains other variables, swap them in accordingly. we need to do this as we build so we capture        # modifications correctly.        # we can assume any key refs exist because we're iterating in order of the variable definitions.        # eg we'll only have uVar17 on the right side if it has previously been defined uVar17 = ...        # so, for each instance in vardef, go ahead and fetch the definition from the var dictionary.                        # string.split just returns a single line list if the split delimiter isn't there.        # join also does nothing if given a single item, other than returning that item.        # so proceed blindly on all var defs                # use re.match to find var instances to avoid cases where eg        # "param_1" matches for "param_17" when testing if def in string.                        # testing: refs in vardef        names = sorted(varnamePattern.findall(vardef), key=len, reverse=True)                for n in names:            n = n.rstrip()            val = vardict[n]            pieces = vardef.split(n)            vardef = val.join(pieces)            vardef = vardef.strip("U")            #print("UPDATED VARDEF: " + vardef)            #vardict.update({key: vardef})        vardict.update({varname: vardef})        # debug...        #print("\n\n")        #for k, v in vardict.items():        #    print("\n\n\nDict entry: " + k + ": " + v)def getFullMBAString(funcStr):    mbaStr = getOriginalRetMBA(funcStr)    getVarDefs(funcStr)    mbaStr = expandMBA(mbaStr)    return mbaStr# input: string (the isolated mba return line - use getOriginalRetMBA)# uses the variable dict set up by getVarDefs to swap all variable instances with their expanded formuladef expandMBA(retLine):    expandedMBA = retLine    #print("Dict in expanded MBA is: ")        # sort first by length so we don't eg swap "var1" for "var17    names = sorted(varnamePattern.findall(expandedMBA), key=len, reverse=True)    while "Var" in expandedMBA:        for n in names:            pieces = expandedMBA.split(n)            expandedMBA = vardict[n].join(pieces)    return expandedMBA.strip("U")    def liftMBAExpressionsToFile(outfilename):    if (os.path.exists(outfilename)):        print("Output file already exists. Skipping")        return        # check that the file is valid    handle = open(outfilename, 'w')        # str(number) + delimiter + gt_str + delimiter + mba_str + "\n")    format_str = "{entryno};{mba_str}\n"        # decomp interface        program = getCurrentProgram()    ifc = DecompInterface()    ifc.openProgram(program)        # get all functions and extract    fList = getAllMBAFunctions()    """    decomp = ifc.decompileFunction(curFunc, 0, ConsoleTaskMonitor())    fullC = decomp.getDecompiledFunction().getC()    """        for i in range (0, len(fList)):        decomp = ifc.decompileFunction(fList[i], 0, ConsoleTaskMonitor())        fullC = decomp.getDecompiledFunction().getC()        mba = getFullMBAString(fullC)        entryStr = format_str.format(entryno = str(i+1), mba_str = mba)        handle.write(entryStr)                if debug:            print("\nCompleted function: " + str(i))            handle.close()        return    print("Starting script: Lift MBA to .txt files")print("""ote: this script ignores windows object files! If you would like to lift from one,      edit the ignoreWords list at the top of this script.""")args = getScriptArgs()if (len(args) != 1):    print("Usage: ghidra_lift_mba.py <output_folderpath>")    outfolder = args[0]if (os.path.isdir(outfolder) == False):    try:        os.makedirs(outfolder)    except Exception as e:        print("Error: could not open or create output folder, with error: ")        print(e)        exit()        thisName = getCurrentProgram().getName()if any(x in thisName for x in ignoreWords):    print("Skipping file: " + thisName)    else:    outFileName = thisName + "_lifted_mba.txt"    liftMBAExpressionsToFile(outfolder + "/" + outFileName)    print("Finished for program: " + outFileName)    